const express = require('express');
const { exec } = require('child_process');
const path = require('path');
const { requireJwtAuth, checkBan, uaParser } = require('~/server/middleware');
const router = express.Router();

// Resolve the repository root regardless of current working directory
// __dirname -> api/server/routes; go up 3 levels to reach repo root
const REPO_ROOT = path.resolve(__dirname, '../../..');

// Helper: wrap text to a max width without breaking words
function wrapText(input, width = 78) {
  const words = String(input || '').split(/\s+/);
  const lines = [];
  let line = '';
  for (const word of words) {
    if (!word) continue;
    if ((line + (line ? ' ' : '') + word).length <= width) {
      line += (line ? ' ' : '') + word;
    } else {
      if (line) lines.push(line);
      if (word.length > width) {
        // hard wrap very long tokens
        for (let i = 0; i < word.length; i += width) {
          lines.push(word.slice(i, i + width));
        }
        line = '';
      } else {
        line = word;
      }
    }
  }
  if (line) lines.push(line);
  return lines;
}

// Helper: build a minimal unified diff that appends wrapped lines to the end of file
function synthesizeAppendDiff(relativePath, textLines) {
  const fs = require('fs');
  const fullPath = path.join(REPO_ROOT, relativePath);
  const content = fs.readFileSync(fullPath, 'utf8');
  let numLines;
  if (content.length === 0) {
    numLines = 0;
  } else {
    const arr = content.split('\n');
    numLines = content.endsWith('\n') ? arr.length - 1 : arr.length;
  }
  const header = `--- a/${relativePath}\n+++ b/${relativePath}\n`;
  const hunk = `@@ -${numLines},0 +${numLines + 1},${textLines.length} @@\n`;
  const body = textLines.map((l) => `+${l}`).join('\n') + '\n';
  return header + hunk + body;
}

// Helper: build a unified diff that replaces the first line containing target with replacementLines
function synthesizeReplaceDiff(relativePath, target, replacementLines) {
  const fs = require('fs');
  const fullPath = path.join(REPO_ROOT, relativePath);
  const content = fs.readFileSync(fullPath, 'utf8');
  const lines = content.split('\n');
  const idx = lines.findIndex((l) => l.includes(target));
  if (idx === -1) {
    throw new Error('Target text not found for replacement');
  }
  const start = idx + 1; // 1-based
  const header = `--- a/${relativePath}\n+++ b/${relativePath}\n`;
  const hunk = `@@ -${start},1 +${start},${replacementLines.length} @@\n`;
  const body = [`-${lines[idx]}`, ...replacementLines.map((l) => `+${l}`)].join('\n') + '\n';
  return header + hunk + body;
}

// Helper: build a unified diff that removes the first line containing target
function synthesizeRemoveDiff(relativePath, target) {
  const fs = require('fs');
  const fullPath = path.join(REPO_ROOT, relativePath);
  const content = fs.readFileSync(fullPath, 'utf8');
  const lines = content.split('\n');
  const idx = lines.findIndex((l) => l.includes(target));
  if (idx === -1) {
    throw new Error('Target text not found for removal');
  }
  const start = idx + 1; // 1-based
  const header = `--- a/${relativePath}\n+++ b/${relativePath}\n`;
  const hunk = `@@ -${start},1 +${start},0 @@\n`;
  const body = `-${lines[idx]}\n`;
  return header + hunk + body;
}

// Heuristic: if request states X is no longer Y, remove matching factual lines
function synthesizeHeuristicContradictionFix(relativePath, requestText) {
  const fs = require('fs');
  const fullPath = path.join(REPO_ROOT, relativePath);
  const content = fs.readFileSync(fullPath, 'utf8');
  const lines = content.split('\n');
  const req = String(requestText || '');

  // Enhanced patterns for contradiction detection
  const patterns = [
    /(.*?)\s+is\s+no\s+longer\s+the?\s+(.*)/i,
    /(.*?)\s+is\s+not\s+the?\s+(.*)/i,
    /(.*?)\s+no\s+longer\s+serves\s+as\s+(.*)/i,
    /(.*?)\s+is\s+no\s+longer\s+(.*)/i,
    /(.*?)\s+has\s+left\s+the?\s+(.*)/i,
    /(.*?)\s+stepped\s+down\s+from\s+(.*)/i,
  ];

  let subject = null;
  let role = null;
  for (const p of patterns) {
    const m = req.match(p);
    if (m && m[1] && m[2]) {
      subject = m[1].trim();
      role = m[2].trim();
      break;
    }
  }

  if (!subject || !role) {
    throw new Error('No clear contradiction found');
  }

  // Find ALL lines that match the subject and role pattern (to remove duplicates too)
  const linesToRemove = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    const subjectPattern = subject.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const rolePattern = role.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    
    // Match various forms: "subject is role", "subject is the role", etc.
    const patterns = [
      new RegExp(`^${subjectPattern}\\s+is\\s+the?\\s+${rolePattern}$`, 'i'),
      new RegExp(`^${subjectPattern}\\s+is\\s+${rolePattern}$`, 'i'),
      new RegExp(`^${subjectPattern}\\s+serves\\s+as\\s+the?\\s+${rolePattern}$`, 'i'),
    ];
    
    if (patterns.some(p => p.test(line))) {
      linesToRemove.push({ index: i, line });
    }
  }

  if (linesToRemove.length === 0) {
    throw new Error('Contradictory line not found');
  }

  // Create a diff that removes all matching lines
  let diff = `--- a/${relativePath}\n+++ b/${relativePath}\n`;
  
  // Sort indices in reverse order to avoid offset issues
  linesToRemove.sort((a, b) => b.index - a.index);
  
  for (const { index } of linesToRemove) {
    const start = index + 1; // 1-based
    diff += `@@ -${start},1 +${start},0 @@\n`;
    diff += `-${lines[index]}\n`;
  }
  
  return diff;
}

// Apply authentication middleware (removed admin requirement for self-improvement)
router.use(requireJwtAuth);
router.use(checkBan);
router.use(uaParser);

// Propose improvement endpoint
router.post('/propose', async (req, res) => {
  const { improvement_request, conversation_context, mode, target, replacement } = req.body;
  
  if (!improvement_request) {
    return res.status(400).json({ error: 'improvement_request is required' });
  }

  try {
    if (!process.env.OPENAI_API_KEY) {
      return res.status(400).json({ error: 'OPENAI_API_KEY not configured on server' });
    }
    let enhancedRequest = improvement_request;
    
    // If conversation context is provided, enhance the request
    if (conversation_context) {
      const { user_question, assistant_response } = conversation_context;
      if (user_question && assistant_response) {
        enhancedRequest = `Context - Previous conversation:
User asked: "${user_question}"
Assistant responded: "${assistant_response}"

Improvement request: ${improvement_request}

Please update the system prompt to handle this type of question better in the future.`;
      }
    }

    const targetFile = 'system_prompt/system_prompt.md';
    // If structured operation provided, include hints for the LLM
    if (mode === 'remove' && target) {
      enhancedRequest += `\n\nOperation: REMOVE\nTarget: ${target}`;
    } else if (mode === 'replace' && target && replacement) {
      enhancedRequest += `\n\nOperation: REPLACE\nTarget: ${target}\nReplacement: ${replacement}`;
    }
    const command = `cd ${REPO_ROOT} && PROMPT_FILE=${targetFile} improvebot/propose.sh "${enhancedRequest.replace(/"/g, '\\"')}"`;
    
    exec(command, { timeout: 60000 }, (error, stdout, stderr) => {
      const details = (stderr || error?.message || '').toString();
      const hasValidDiff = typeof stdout === 'string' && /\n\+\+\+ b\//.test(stdout) && /\n--- a\//.test(stdout);

      if (!error && hasValidDiff) {
        return res.json({
          success: true,
          diff: stdout,
          message: 'Improvement proposal generated',
          context: conversation_context
        });
      }

      // Fallback: synthesize a minimal valid diff based on requested mode or contradiction heuristic
      try {
        let diff;
        if (mode === 'remove' && target) {
          diff = synthesizeRemoveDiff(targetFile, target);
        } else if (mode === 'replace' && target && replacement) {
          const wrappedRepl = replacement
            .split('\n')
            .flatMap((ln) => wrapText(ln, 78));
          diff = synthesizeReplaceDiff(targetFile, target, wrappedRepl);
        } else {
          // Try contradiction heuristic first
          try {
            diff = synthesizeHeuristicContradictionFix(targetFile, enhancedRequest);
          } catch (_) {
            const wrapped = wrapText(enhancedRequest, 78);
            diff = synthesizeAppendDiff(targetFile, wrapped);
          }
        }
        console.warn('[Improvebot] Falling back to synthesized diff. Reason:', details || (error ? 'child process error' : 'invalid diff'));
        return res.json({ success: true, diff, message: 'Synthesized diff (LLM fallback)' });
      } catch (fallbackErr) {
        console.error('Propose fallback failed:', fallbackErr);
        const hint = details.includes('ERROR: Set OPENAI_API_KEY')
          ? 'Server missing OPENAI_API_KEY. Set it in docker-compose.override.yml and restart.'
          : undefined;
        return res.status(500).json({ error: 'Failed to generate proposal', details, hint });
      }
    });
  } catch (error) {
    res.status(500).json({ error: 'Internal server error', details: error.message });
  }
});

// Apply improvement endpoint
router.post('/apply', async (req, res) => {
  const { diff, approver, why, impact } = req.body;
  
  if (!diff) {
    return res.status(400).json({ error: 'diff is required' });
  }

  try {
    // Write diff to temp file with basic cleanup
    const fs = require('fs');
    let cleanDiff = diff.trim();
    
    // Basic cleanup - remove any leading/trailing non-diff content
    const lines = cleanDiff.split('\n');
    let startIdx = 0;
    let endIdx = lines.length;
    
    // Find start of actual diff
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].startsWith('--- a/')) {
        startIdx = i;
        break;
      }
    }
    
    // If we found a proper diff start, use it
    if (startIdx > 0) {
      cleanDiff = lines.slice(startIdx).join('\n');
    }
    
    const tmpFile = `/tmp/improvebot_${Date.now()}.diff`;
    fs.writeFileSync(tmpFile, cleanDiff);

    // Derive approver from authenticated user if not provided
    const autoApprover =
      approver || req.user?.name || req.user?.email || `User ${req.user?.id || ''}`.trim();

    const env = {
      ...process.env,
      ALLOWED_PROMPT_FILE: 'system_prompt/system_prompt.md',
      APPROVER: autoApprover || 'LibreChat Admin',
      WHY: why || 'User-approved system improvement',
      IMPACT: impact || 'Enhanced capabilities'
    };

    const command = `cd ${REPO_ROOT} && improvebot/apply_diff.sh "${tmpFile}"`;
    
    exec(command, { env, timeout: 30000 }, (error, stdout, stderr) => {
      // Clean up temp file
      fs.unlinkSync(tmpFile);
      
      if (error) {
        console.error('Apply error:', error, stderr);
        return res.status(500).json({ error: 'Failed to apply improvement', details: stderr || error.message });
      }
      
      res.json({
        success: true,
        message: 'Improvement applied successfully',
        output: stdout
      });
    });
  } catch (error) {
    res.status(500).json({ error: 'Internal server error', details: error.message });
  }
});

// Get current system prompt
router.get('/prompt', (req, res) => {
  try {
    const fs = require('fs');
    const promptPath = path.join(process.cwd(), 'system_prompt/system_prompt.md');
    const content = fs.readFileSync(promptPath, 'utf8');
    
    res.json({
      success: true,
      content: content,
      path: 'system_prompt/system_prompt.md'
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to read prompt file', details: error.message });
  }
});

// Get changelog
router.get('/changelog', (req, res) => {
  try {
    const fs = require('fs');
    const changelogPath = path.join(process.cwd(), 'system_prompt/prompt_changelog.md');
    const content = fs.readFileSync(changelogPath, 'utf8');
    
    res.json({
      success: true,
      content: content
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to read changelog', details: error.message });
  }
});

// Re-answer endpoint - for testing improved responses
router.post('/re-answer', async (req, res) => {
  const { question, context } = req.body;
  
  if (!question) {
    return res.status(400).json({ error: 'question is required' });
  }

  try {
    const fs = require('fs');
    const promptPath = path.join(process.cwd(), 'system_prompt/system_prompt.md');
    const systemPrompt = fs.readFileSync(promptPath, 'utf8');
    
    // This is a simple implementation - in a real system you'd call your LLM
    // For now, we'll return a test response indicating the improvement worked
[This is a test response - in production, this would call your LLM with the updated system prompt]`;

    res.json({
      success: true,
      improved_response: testResponse,
      system_prompt_used: systemPrompt.substring(0, 200) + '...',
      original_question: question,
      context: context
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to generate improved response', details: error.message });
  }
});
    res.status(500).json({ error: "Failed to generate improved response", details: error.message });
module.exports = router;
    const testResponse = `Based on the updated system prompt, here's my improved response:

Previous response indicated knowledge gap for: "${question}"

With the improved knowledge base, I can now provide better guidance. The system has been enhanced to handle this type of question more effectively.

[This is a test response - in production, this would call your LLM with the updated system prompt]`;
